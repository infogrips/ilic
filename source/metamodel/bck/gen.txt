reading script f:\users\mgpro\dev\ig_main\trunk\source\c\ilic\metamodel\genvisitor.cfg ...

******************************
*                            *
* INTERLIS Tools             *
*                            *
* Version 2012.0             *
*                            *
* (c) infoGrips 1997-2012    *
*                            *
******************************


static void visitMMObject(MetaModelVisitor *visitor, MMObject *t)
{

   /*
   class MMObject {
   public:
      int _line;
   */

   if (!visitor->visitMMObjectOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);

}

static void visitDocText(MetaModelVisitor *visitor, DocText *t)
{

   /*
   struct DocText : public MMObject {
   public:
      string Name;
      string Text;
   */

   if (!visitor->visitDocTextOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitDocText(t);

}

static void visitMetaAttribute(MetaModelVisitor *visitor, MetaAttribute *t)
{

   /*
   class MetaAttribute : public MMObject {
      // OID: <Parent-OID>.METAOBJECT.Name
   public:
      string Name;
      string Value;
      // ROLE from ASSOCIATION MetaAttributes
      MetaElement *MetaElement;
   */

   if (!visitor->visitMetaAttributeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitMetaAttribute(t);

}

static void visitMetaElement(MetaModelVisitor *visitor, MetaElement *t)
{

   /*
   class MetaElement : public MMObject { // ABSTRACT
      // OID: <Parent-OID>.Name
   public:
      string Name;
      list <DocText *> Documentation;
      // ROLE from ASSOCIATION MetaAttributes
      list <MetaAttribute *> MetaAttribute;
      // ROLE from ASSOCIATION PackageElements
      Package *ElementInPackage;
   */

   if (!visitor->visitMetaElementOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitMetaElement(t);

   for (auto v : t->Documentation) {
      visitDocText(visitor,v);
   }

   for (auto v : t->MetaAttribute) {
      visitMetaAttribute(visitor,v);
   }

}

static void visitExtendableME(MetaModelVisitor *visitor, ExtendableME *t)
{

   /*
   class ExtendableME : public MetaElement {
   public:
      bool Abstract = false;
      bool Generic = false; // 2.4
      bool Final = false;
      // ROLE from ASSOCIATION Inheritance
      ExtendableME *Super;
      // ROLE from ASSOCIATION Inheritance
      list <ExtendableME *> Sub;
   */

   if (!visitor->visitExtendableMEOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMetaElement(t);
   visitor->visitExtendableME(t);

   for (auto v : t->Sub) {
      visitExtendableME(visitor,v);
   }

}

static void visitPackage(MetaModelVisitor *visitor, Package *t)
{

   /*
   class Package : public MetaElement {
   public:
      // ROLE from ASSOCIATION PackageElements
      list <MetaElement *> Element;
   */

   if (!visitor->visitPackageOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMetaElement(t);
   visitor->visitPackage(t);

   for (auto v : t->Element) {
      visitMetaElement(visitor,v);
   }

}

static void visitImport(MetaModelVisitor *visitor, Import *t)
{

   /*
   class Import : public MMObject { // ASSOCIATION
   public:
      Package *ImportingP;
      Package *ImportedP;
   */

   if (!visitor->visitImportOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitImport(t);

}

static void visitIli1Format(MetaModelVisitor *visitor, Ili1Format *t)
{

   /*
   struct Ili1Format : public MMObject {
   public:
      bool isFree = false;
      int LineSize = 80;
      int tidSize = 10;
      char blankCode = ' ';
      char undefinedCode = '@';
      char continueCode = '\\';
      string Font = "";
      enum { TID_I16, TID_I32, TID_ANY, TID_EXPLANATION } tidKind = TID_ANY;
      string tidExplanation = ""; // defined when tidKind == TID_EXPLANATION
   */

   if (!visitor->visitIli1FormatOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitIli1Format(t);

}

static void visitModel(MetaModelVisitor *visitor, Model *t)
{

   /*
   class Model : public Package {
   public:
      string iliVersion;
      bool Contracted = false;
      enum { NormalM, TypeM, RefSystemM, SymbologyM } Kind;
      string Language;
      string At;
      string Version;
      string VersionExplanation;
      bool NoIncrementalTransfer = true; // 2.4
      string CharSetIANAName; // 2.4
      string xmlns; // 2.4
      string ili1Transfername;
      Ili1Format *ili1Format;
   */

   if (!visitor->visitModelOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitPackage(t);
   visitor->visitModel(t);

}

static void visitSubModel(MetaModelVisitor *visitor, SubModel *t)
{

   /*
   class SubModel : public Package {
      // MetaElement.Name := TopicName as defined in the INTERLIS-Model
   public:
   */

   if (!visitor->visitSubModelOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitPackage(t);
   visitor->visitSubModel(t);

}

static void visitType(MetaModelVisitor *visitor, Type *t)
{

   /*
   class Type : public ExtendableME { // ABSTRACT
   public:
      // role from ASSOCIATION AttrOrParamType
      list<AttrOrParam *> AttrOrParam;
      // role form ASSOCIATION BaseType
      list<TypeRelatedType *> TRT;
      // role from ASSOCIATION LocalFType
      FunctionDef *LFTParent;
      // role from ASSOCIATION ResultType
      list <FunctionDef *> Function;
      // role form ASSOCIATION ArgumentType
      list<Argument *> Argument;
   */

   if (!visitor->visitTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitExtendableME(t);
   visitor->visitType(t);

   for (auto v : t->AttrOrParam) {
      visitAttrOrParam(visitor,v);
   }

   for (auto v : t->TRT) {
      visitTypeRelatedType(visitor,v);
   }

   for (auto v : t->Function) {
      visitFunctionDef(visitor,v);
   }

   for (auto v : t->Argument) {
      visitArgument(visitor,v);
   }

}

static void visitMultiplicity(MetaModelVisitor *visitor, Multiplicity *t)
{

   /*
   struct Multiplicity : public MMObject {
   public:
      int Min;
      int Max;
   */

   if (!visitor->visitMultiplicityOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitMultiplicity(t);

}

static void visitConstraint(MetaModelVisitor *visitor, Constraint *t)
{

   /*
   class Constraint : public MetaElement { // ABSTRACT, 2.4
   public:
      // role from ASSOCIATION DomainConstraint
      DomainType *toDomain; // 2.4
      // role from ASSOCIATION ClassConstraint
      Class *ToClass; // 2.4
   */

   if (!visitor->visitConstraintOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMetaElement(t);
   visitor->visitConstraint(t);

}

static void visitDomainType(MetaModelVisitor *visitor, DomainType *t)
{

   /*
   class DomainType : public Type { // ABSTRACT
      // MetaElement.Name :=
      // DomainName if defined explicitly as a domain,
      // "Type" if defined within an attribute definition
   public:
      bool Mandatory = false;
      // role from ASSOCIATION BasketOID
      list <DataUnit *> ForDataUnit;
      // role form ASSOCIATION DomainConstraint
      list <Constraint *> Constraint;
      // role form ASSOCIATION ConcreteForGeneric
      GenericDef *GenericDef;
   */

   if (!visitor->visitDomainTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitType(t);
   visitor->visitDomainType(t);

   for (auto v : t->ForDataUnit) {
      visitDataUnit(visitor,v);
   }

   for (auto v : t->Constraint) {
      visitConstraint(visitor,v);
   }

}

static void visitClass(MetaModelVisitor *visitor, Class *t)
{

   /*
   class Class : public Type {
      // MetaElement.Name := StructureName, ClassName,
      //                     AssociationName, ViewName
      //                     as defined in the INTERLIS-Model
   public:
      enum {Structure,ClassVal,ViewVal,Association} Kind;
      Multiplicity Multiplicity; // for associations only
      list<Constraint *> Constraints;
      bool EmbeddedRoleTransfer = false;
      bool ili1OptionalTable = false;
      // role from ASSOCIATION LocalType
      metamodel::AttrOrParam *LTParent;
      // role from ASSOCIATION ClassAttr
      list<AttrOrParam *> ClassAttribute;
      // role from ASSOCIATION AssocRole
      list<Role *> Role;
      // role from ExplicitAssocAcc
      list<ExplicitAssocAcc *> ExplicitAssocAccess;
      // role from ASSOCIATION MetaObjectClass
      list<MetaObjectDef *> MetaObjectDef;
      // role from ASSOCIATION StructOfFormat
      list<FormattedType *> FormattedType;
      // role form ASSOCIATION ObjectOID
      DomainType * Oid; // RESTRICTION(TextType; NumType; AnyOIDType)
      // role from ASSOCIATION ARefOf
      list<AttributeRefType *> ForARef;
      // role from ASSOCIATION LineFormStructure
      list<LineForm *> LineForm;
      // role from ASSOCIATION LineAttr
      list<LineType *> LineType;
      // role from ASSOCIATION BaseViewRef
      list<RenamedBaseView *> RenamedBaseView;
      // role from ASSOCIATION DerivedAssoc
      View *View;
      // role from ASSOCIATION GraphicBase
      //list<Graphic *> Graphic;
      // role from ASSOCIATION SignClass
      list <DrawingRule *> DrawingRule;
      // from from ASSOCIATION ClassConstraint
      list<Constraint *> Constraint;
   */

   if (!visitor->visitClassOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitType(t);
   visitor->visitClass(t);

   for (auto v : t->Constraints) {
      visitConstraint(visitor,v);
   }

   for (auto v : t->ClassAttribute) {
      visitAttrOrParam(visitor,v);
   }

   for (auto v : t->Role) {
      visitRole(visitor,v);
   }

   for (auto v : t->ExplicitAssocAccess) {
      visitExplicitAssocAcc(visitor,v);
   }

   for (auto v : t->MetaObjectDef) {
      visitMetaObjectDef(visitor,v);
   }

   for (auto v : t->FormattedType) {
      visitFormattedType(visitor,v);
   }

   for (auto v : t->ForARef) {
      visitAttributeRefType(visitor,v);
   }

   for (auto v : t->LineForm) {
      visitLineForm(visitor,v);
   }

   for (auto v : t->LineType) {
      visitLineType(visitor,v);
   }

   for (auto v : t->RenamedBaseView) {
      visitRenamedBaseView(visitor,v);
   }

   for (auto v : t->DrawingRule) {
      visitDrawingRule(visitor,v);
   }

   for (auto v : t->Constraint) {
      visitConstraint(visitor,v);
   }

}

static void visitAttrOrParam(MetaModelVisitor *visitor, AttrOrParam *t)
{

   /*
   class AttrOrParam : public ExtendableME {
      // MetaElement.Name := AttributeName, ParameterName
      //                    as defined in the INTERLIS-Model
   public:
      enum { NoSubDiv, SubDiv, ContSubDiv } SubdivisionKind;
      bool Transient = false;
      list<Expression *> Derivates;
      // ROLE from ASSOCIATION LocalType
      list<Type *> LocalType;
      // ROLE from ASSOCIATION AttrOrParamType
      Type *Type;
      // ROLE from ASSOCIATION ClassAttr
      Class *AttrParent;
   */

   if (!visitor->visitAttrOrParamOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitExtendableME(t);
   visitor->visitAttrOrParam(t);

   for (auto v : t->Derivates) {
      visitExpression(visitor,v);
   }

   for (auto v : t->LocalType) {
      visitType(visitor,v);
   }

}

static void visitTypeRelatedType(MetaModelVisitor *visitor, TypeRelatedType *t)
{

   /*
   class TypeRelatedType : public DomainType { // ABSTRACT
   public:
      // Role from ASSOCIATION BaseType
      Type *BaseType;
   */

   if (!visitor->visitTypeRelatedTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitDomainType(t);
   visitor->visitTypeRelatedType(t);

}

static void visitTypeRestriction(MetaModelVisitor *visitor, TypeRestriction *t)
{

   /*
   class TypeRestriction : public MMObject {
   public:
      TypeRelatedType *TRTR;
      Type *TypeRestriction;
   */

   if (!visitor->visitTypeRestrictionOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitTypeRestriction(t);

}

static void visitMultiValue(MetaModelVisitor *visitor, MultiValue *t)
{

   /*
   class MultiValue : public TypeRelatedType {
      // MetaElement.Name := "Type" because always defined
      //                     within an attribute definition
   public:
      bool Ordered = false;
      Multiplicity Multiplicity;
   */

   if (!visitor->visitMultiValueOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitTypeRelatedType(t);
   visitor->visitMultiValue(t);

}

static void visitClassRelatedType(MetaModelVisitor *visitor, ClassRelatedType *t)
{

   /*
   class ClassRelatedType : public DomainType { // ABSTRACT
   public:
   */

   if (!visitor->visitClassRelatedTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitDomainType(t);
   visitor->visitClassRelatedType(t);

}

static void visitBaseClass(MetaModelVisitor *visitor, BaseClass *t)
{

   /*
   class BaseClass : public MMObject { // ASSOCIATION
   public:
      ClassRelatedType *CRT;
      Class *BaseClass;
   */

   if (!visitor->visitBaseClassOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitBaseClass(t);

}

static void visitClassRestriction(MetaModelVisitor *visitor, ClassRestriction *t)
{

   /*
   class ClassRestriction : public MMObject { // ASSOCIATION
   public:
      ClassRelatedType *CRTR;
      Class *ClassRestriction;
   */

   if (!visitor->visitClassRestrictionOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitClassRestriction(t);

}

static void visitReferenceType(MetaModelVisitor *visitor, ReferenceType *t)
{

   /*
   class ReferenceType : public ClassRelatedType {
   public:
      bool External = false;
   */

   if (!visitor->visitReferenceTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitClassRelatedType(t);
   visitor->visitReferenceType(t);

}

static void visitRole(MetaModelVisitor *visitor, Role *t)
{

   /*
   class Role : public ReferenceType {
      // MetaElement.Name := RoleName as defined in the INTERLIS-Model
   public:
      enum { Assoc, Aggr, Comp } Strongness;
      bool Ordered = false;
      Multiplicity Multiplicity;
      list<Expression *> Derivates;
      bool EmbeddedTransfer = false;
      // role from ASSOCIATION AssocRole
      Class *Association;
      // role from ASSOCIATION AssocAccOrign
      list<ExplicitAssocAccess *> UseAsOrigin;
      // role from ASSOCIATION AssocAccTarget
      list<ExplicitAssocAccess *> UseAsTarget;
   */

   if (!visitor->visitRoleOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitReferenceType(t);
   visitor->visitRole(t);

   for (auto v : t->Derivates) {
      visitExpression(visitor,v);
   }

   for (auto v : t->UseAsOrigin) {
      visitExplicitAssocAccess(visitor,v);
   }

   for (auto v : t->UseAsTarget) {
      visitExplicitAssocAccess(visitor,v);
   }

}

static void visitExplicitAssocAccess(MetaModelVisitor *visitor, ExplicitAssocAccess *t)
{

   /*
   class ExplicitAssocAccess : public ExtendableME {
   public:
      // role from ASSOCIATION ExplicitAssocAcc
      Class *AssocAccOf;
      // role from ASSOCIATION AssocAccOrign
      Role *OriginRole;
      // role from ASSOCIATION AssocAccTarget
      Role *TargetRole;
   */

   if (!visitor->visitExplicitAssocAccessOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitExtendableME(t);
   visitor->visitExplicitAssocAccess(t);

}

static void visitAssocAcc(MetaModelVisitor *visitor, AssocAcc *t)
{

   /*
   class AssocAcc : public MMObject { // ASSOCIATION
   public:
      Class *Class;
      Role *AssocAcc; // Role OR ExplicitAssocAccess, to do !!!
   */

   if (!visitor->visitAssocAccOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitAssocAcc(t);

}

static void visitTransferElement(MetaModelVisitor *visitor, TransferElement *t)
{

   /*
   class TransferElement : public MMObject { // ASSOCIATION
   public:
      Class *TransferClass;
      AttrOrParam *TransferElement; // AttrOrParam OR ExplicitAssocAccess OR Role, to do !!!
   */

   if (!visitor->visitTransferElementOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitTransferElement(t);

}

static void visitIli1TransferElement(MetaModelVisitor *visitor, Ili1TransferElement *t)
{

   /*
   class Ili1TransferElement : public MMObject { // ASSOCIATION
   public:
      Class *Ili1TransferClass;
      AttrOrParam *Ili1RefAttr; // ORDERED AttrOrParam OR Role, to do !!!
   */

   if (!visitor->visitIli1TransferElementOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitIli1TransferElement(t);

}

static void visitDataUnit(MetaModelVisitor *visitor, DataUnit *t)
{

   /*
   class DataUnit : public ExtendableME {
   public:
      // Name (EXTENDED): TEXT := "BASKET";
      bool ViewUnit = false;
      string DataUnitName;
      // role from ASSOCIATION MetaDataUnit 
      list <MetaBasketDef *> MetaBasketDef;
      // role from ASSOCIATION BasketOID
      DomainType *Oid; // RESTRICTION(TextType; NumType; AnyOIDType);
   */

   if (!visitor->visitDataUnitOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitExtendableME(t);
   visitor->visitDataUnit(t);

   for (auto v : t->MetaBasketDef) {
      visitMetaBasketDef(visitor,v);
   }

}

static void visitDependency(MetaModelVisitor *visitor, Dependency *t)
{

   /*
   class Dependency : public MMObject { // m:n ASSOCIATION
   public:
      DataUnit *Using;
      DataUnit *Dependent;
   */

   if (!visitor->visitDependencyOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitDependency(t);

}

static void visitAllowedInBasket(MetaModelVisitor *visitor, AllowedInBasket *t)
{

   /*
   class AllowedInBasket : public MMObject { // m:n ASSOCIATION
   public:
      DataUnit *OfDataUnit;
      Class *ClassInBasket;
   */

   if (!visitor->visitAllowedInBasketOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitAllowedInBasket(t);

}

static void visitContext(MetaModelVisitor *visitor, Context *t)
{

   /*
   class Context : public MetaElement {
   public:
   */

   if (!visitor->visitContextOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMetaElement(t);
   visitor->visitContext(t);

}

static void visitGenericDef(MetaModelVisitor *visitor, GenericDef *t)
{

   /*
   class GenericDef : public MMObject { 
   public:
      DomainType *OID; 
      Context *Context;
      list<DomainType *> GenericDomain;
      // role from ASSOCIATION ConcreteForGeneric
      list<DomainType *> ConcreteDomain;
   */

   if (!visitor->visitGenericDefOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitGenericDef(t);

   for (auto v : t->GenericDomain) {
      visitDomainType(visitor,v);
   }

   for (auto v : t->ConcreteDomain) {
      visitDomainType(visitor,v);
   }

}

static void visitUnit(MetaModelVisitor *visitor, Unit *t)
{

   /*
   class Unit : public ExtendableME {
      // MetaElement.Name := ShortName as defined in the INTERLIS-Model
   public:
      enum { BaseU, DerivedU, ComposedU } Kind;
      Expression *Definition;
      // role from ASSOCIATION NumUnit
      list <NumType *> Num;
      string _unitshort;
   */

   if (!visitor->visitUnitOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitExtendableME(t);
   visitor->visitUnit(t);

   for (auto v : t->Num) {
      visitNumType(visitor,v);
   }

}

static void visitMetaBasketDef(MetaModelVisitor *visitor, MetaBasketDef *t)
{

   /*
   class MetaBasketDef : public ExtendableME {
      // MetaElement.Name := BasketName as defined in the INTERLIS-Model
   public:
      enum { SignB, RefSystemB } Kind;
      // role from ASSOCIATION MetaDataUnit
      DataUnit *MetaDataTopic;
      // role from ASSOCIATION MetaBasketMembers
      MetaObjectDef * Member;
   */

   if (!visitor->visitMetaBasketDefOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitExtendableME(t);
   visitor->visitMetaBasketDef(t);

}

static void visitMetaObjectDef(MetaModelVisitor *visitor, MetaObjectDef *t)
{

   /*
   class MetaObjectDef : public MetaElement {
      // MetaElement.Name := MetaObjectName as defined
      // in the INTERLIS-Model
   public:
      bool IsRefSystem = false;
      // role from ASSOCIATION MetaBasketMembers
      list <MetaBasketDef *> MetaBasketDef;
      // role from ASSOCIATION MetaObjectClass
      Class *Class;
   */

   if (!visitor->visitMetaObjectDefOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMetaElement(t);
   visitor->visitMetaObjectDef(t);

   for (auto v : t->MetaBasketDef) {
      visitMetaBasketDef(visitor,v);
   }

}

static void visitBooleanType(MetaModelVisitor *visitor, BooleanType *t)
{

   /*
   class BooleanType : public DomainType {
   public:
   */

   if (!visitor->visitBooleanTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitDomainType(t);
   visitor->visitBooleanType(t);

}

static void visitTextType(MetaModelVisitor *visitor, TextType *t)
{

   /*
   class TextType : public DomainType {
   public:
      enum { MText, Text, Name, Uri } Kind;
      int MaxLength = 0;
   */

   if (!visitor->visitTextTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitDomainType(t);
   visitor->visitTextType(t);

}

static void visitBlackboxType(MetaModelVisitor *visitor, BlackboxType *t)
{

   /*
   class BlackboxType : public DomainType {
   public:
      enum { Binary, Xml } Kind;
   */

   if (!visitor->visitBlackboxTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitDomainType(t);
   visitor->visitBlackboxType(t);

}

static void visitNumType(MetaModelVisitor *visitor, NumType *t)
{

   /*
   class NumType : public DomainType {
      // MetaElement.Name :=
      // DomainName if defined explicitly as a domain,
      // "Type" if defined within an attribute definition,
      // "C1", "C2", "C3" if defined within a coordinate type
   public:
      string Min;
      string Max;
      bool Circular = false;
      bool Clockwise = false;
      // frole from ASSOCIATION NumUnit
      Unit *Unit;
   */

   if (!visitor->visitNumTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitDomainType(t);
   visitor->visitNumType(t);

}

static void visitCoordType(MetaModelVisitor *visitor, CoordType *t)
{

   /*
   class CoordType : public DomainType {
   public:
      int NullAxis;
      int PiHalfAxis;
      bool Multi = false; // 2.4
      // role from ASSOCIATION LineCoord
      list <LineType *> LineType;
   */

   if (!visitor->visitCoordTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitDomainType(t);
   visitor->visitCoordType(t);

   for (auto v : t->LineType) {
      visitLineType(visitor,v);
   }

}

static void visitAxisSpec(MetaModelVisitor *visitor, AxisSpec *t)
{

   /*
   class AxisSpec : public MMObject { // ASSOCIATION
   public:
      CoordType *CoordType;
      NumType *Axis;
   */

   if (!visitor->visitAxisSpecOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitAxisSpec(t);

}

static void visitNumsRefSys(MetaModelVisitor *visitor, NumsRefSys *t)
{

   /*
   class NumsRefSys : public MMObject { // ASSOCIATION
   public:
      NumType *NumType;
      MetaObjectDef *RefSys; // MetaObjectDef OR CoordType, to do !!!
      Axis *AxisInd;
   */

   if (!visitor->visitNumsRefSysOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitNumsRefSys(t);

}

static void visitFormattedType(MetaModelVisitor *visitor, FormattedType *t)
{

   /*
   class FormattedType : public NumType {
   public:
      string Format;
      // role from ASSOCIATION
      Class *Struct;
   */

   if (!visitor->visitFormattedTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitNumType(t);
   visitor->visitFormattedType(t);

}

static void visitAnyOIDType(MetaModelVisitor *visitor, AnyOIDType *t)
{

   /*
   class AnyOIDType : public DomainType {
   public:
      // role from ASSOCIATION ObjectOID
      list<Class *> Class;
   */

   if (!visitor->visitAnyOIDTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitDomainType(t);
   visitor->visitAnyOIDType(t);

   for (auto v : t->Class) {
      visitClass(visitor,v);
   }

}

static void visitFunctionDef(MetaModelVisitor *visitor, FunctionDef *t)
{

   /*
   class FunctionDef : public MetaElement {
      // MetaElement.Name := FunctionName as defined in the INTERLIS-Model
   public:
      string Explanation;
      // role from ASSOCIATION LocalFType
      Type *LocalType;
      Type *ResultType;
      // role from ASSOCIATION FormalArgument
      list <Argument *> Argument;
   */

   if (!visitor->visitFunctionDefOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMetaElement(t);
   visitor->visitFunctionDef(t);

   for (auto v : t->Argument) {
      visitArgument(visitor,v);
   }

}

static void visitArgument(MetaModelVisitor *visitor, Argument *t)
{

   /*
   class Argument : public MetaElement {
      // MetaElement.Name := ArgumentName as defined in the INTERLIS-Model
   public:
      enum { TypeVal, EnumVal, EnumTreeVal } Kind;
      // role from ASSOCIATION FormalArgument =
      FunctionDef * Function;
      // role from ASSOCIATION ArgumentType
      Type *Type;
   */

   if (!visitor->visitArgumentOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMetaElement(t);
   visitor->visitArgument(t);

}

static void visitClassRefType(MetaModelVisitor *visitor, ClassRefType *t)
{

   /*
   class ClassRefType : public ClassRelatedType {
   public:
   */

   if (!visitor->visitClassRefTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitClassRelatedType(t);
   visitor->visitClassRefType(t);

}

static void visitObjectType(MetaModelVisitor *visitor, ObjectType *t)
{

   /*
   class ObjectType : public ClassRelatedType {
   public:
      bool Multiple = false;
   */

   if (!visitor->visitObjectTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitClassRelatedType(t);
   visitor->visitObjectType(t);

}

static void visitAttributeRefType(MetaModelVisitor *visitor, AttributeRefType *t)
{

   /*
   class AttributeRefType : public DomainType {
   public:
      // role from ASSOCIATION ARefOf
      Class *Of; // Class OR AttrOrParam OR Argument, to do !!!
   */

   if (!visitor->visitAttributeRefTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitDomainType(t);
   visitor->visitAttributeRefType(t);

}

static void visitARefRestriction(MetaModelVisitor *visitor, ARefRestriction *t)
{

   /*
   class ARefRestriction : public MMObject { // ASSOCIATION
   public:
      AttributeRefType * ARef;
      Type *Type;
   */

   if (!visitor->visitARefRestrictionOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitARefRestriction(t);

}

static void visitEnumType(MetaModelVisitor *visitor, EnumType *t)
{

   /*
   class EnumType : public DomainType {
   public:
      enum {Unordered, Ordered, Circular} Order;
      // role from ASSOCIATION TopNode
      list <EnumNode *> TopNode;
      // role from ASSOCIATION TreeValueTypeOf
      list <EnumTreeValueType *> ETVT;
   */

   if (!visitor->visitEnumTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitDomainType(t);
   visitor->visitEnumType(t);

   for (auto v : t->TopNode) {
      visitEnumNode(visitor,v);
   }

   for (auto v : t->ETVT) {
      visitEnumTreeValueType(visitor,v);
   }

}

static void visitEnumNode(MetaModelVisitor *visitor, EnumNode *t)
{

   /*
   class EnumNode : public ExtendableME {
      // MetaElement.Name := "TOP" for topnode,
      //                     enumeration value (without constant prefix #)
      //                     for all real nodes
   public:
      // role from ASSOCIATION TopNode
      EnumType *EnumType;
      // roles from ASSOCIATION SubNode
      EnumNode *ParentNode;
      list <EnumNode *> Node;
   */

   if (!visitor->visitEnumNodeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitExtendableME(t);
   visitor->visitEnumNode(t);

   for (auto v : t->Node) {
      visitEnumNode(visitor,v);
   }

}

static void visitEnumTreeValueType(MetaModelVisitor *visitor, EnumTreeValueType *t)
{

   /*
   class EnumTreeValueType : public DomainType {
   public:
      // role from ASSOCIATION TreeValueTypeOf
      EnumType *ET;
   */

   if (!visitor->visitEnumTreeValueTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitDomainType(t);
   visitor->visitEnumTreeValueType(t);

}

static void visitLineForm(MetaModelVisitor *visitor, LineForm *t)
{

   /*
   class LineForm : public MetaElement {
      // MetaElement.Name := LineFormName as defined in the INTERLIS-Model
   public:
      // role from ASSOCIATION LineFormStructure
      Class *Structure;
   */

   if (!visitor->visitLineFormOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMetaElement(t);
   visitor->visitLineForm(t);

}

static void visitLineType(MetaModelVisitor *visitor, LineType *t)
{

   /*
   class LineType : public DomainType {
   public:
      enum {Polyline, DirectedPolyline, Surface, Area} Kind;
      string MaxOverlap;
      bool Multi = false; // 2.4
      // role from ASSOCIATION LineCoord
      CoordType *CoordType;
      // role from ASSOCIATION LineAttr
      Class *LAStructure;
   */

   if (!visitor->visitLineTypeOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitDomainType(t);
   visitor->visitLineType(t);

}

static void visitLinesForm(MetaModelVisitor *visitor, LinesForm *t)
{

   /*
   class LinesForm : public MMObject { // ASSOCIATION
   public:
      LineType *LineType;
      LineForm *LineForm;
   */

   if (!visitor->visitLinesFormOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitLinesForm(t);

}

static void visitView(MetaModelVisitor *visitor, View *t)
{

   /*
   class View : public Class {
   public:
      enum {Projection, Join, Union,
            Aggregation_All, Aggregation_Equal,
            Inspection_Normal, Inspection_Area} FormationKind;

      list<Expression *> FormationParameter; // PathOrInspFactor only
                          // Aggr.Equal: UniqueEl
                          // Inspection: Attributepath
      Expression *Where;
      bool Transient = false;
      // role from ASSOCIATION BaseViewDef
      // list<RenamedBaseView *> RenamedBaseView;
      // role from ASSOCIATION DerivedAssoc
      list <Class *> DeriAssoc;
   */

   if (!visitor->visitViewOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitClass(t);
   visitor->visitView(t);

   for (auto v : t->FormationParameter; // PathOrInspFactor onl) {
      visitExpression(visitor,v);
   }

   for (auto v : t->DeriAssoc) {
      visitClass(visitor,v);
   }

}

static void visitRenamedBaseView(MetaModelVisitor *visitor, RenamedBaseView *t)
{

   /*
   class RenamedBaseView : public ExtendableME {
      // MetaElement.Name := Name as defined in the INTERLIS-Model
   public:
      bool OrNull = false;
      // role from ASSOCIATION BaseViewDef
      View *View;
      // role from ASSOCIATION BaseViewRef
      Class *BaseView;
   */

   if (!visitor->visitRenamedBaseViewOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitExtendableME(t);
   visitor->visitRenamedBaseView(t);

}

static void visitExpression(MetaModelVisitor *visitor, Expression *t)
{

   /*
   class Expression : public MMObject { // ABSTRACT
   public:
   */

   if (!visitor->visitExpressionOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitExpression(t);

}

static void visitUnaryExpr(MetaModelVisitor *visitor, UnaryExpr *t)
{

   /*
   struct UnaryExpr : public Expression {
   public:
      enum {Not, Defined} Operation;
      Expression *SubExpression;
   */

   if (!visitor->visitUnaryExprOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitExpression(t);
   visitor->visitUnaryExpr(t);

}

static void visitCompoundExpr(MetaModelVisitor *visitor, CompoundExpr *t)
{

   /*
   struct CompoundExpr : public Expression {
   public:
      enum {Implication, And, Or, Mult, Div, // 2.4 Implication
            Relation_Equal, Relation_NotEqual,
            Relation_LessOrEqual, Relation_GreaterOrEqual,
            Relation_Less, Relation_Greater} Operation;
      list <Expression *> SubExpressions;
   */

   if (!visitor->visitCompoundExprOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitExpression(t);
   visitor->visitCompoundExpr(t);

   for (auto v : t->SubExpressions) {
      visitExpression(visitor,v);
   }

}

static void visitFactor(MetaModelVisitor *visitor, Factor *t)
{

   /*
   struct Factor : public Expression { // ABSTRACT
   public:
   */

   if (!visitor->visitFactorOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitExpression(t);
   visitor->visitFactor(t);

}

static void visitPathEl(MetaModelVisitor *visitor, PathEl *t)
{

   /*
   struct PathEl : public MMObject {
   public:
      enum {This, ThisArea, ThatArea, Parent,
            ReferenceAttr, AssocPath, Role, ViewBase,
            Attribute, MetaObject} Kind;
      MetaElement *Ref;
      int NumIndex;
      enum {First, Last} SpecIndex;
   */

   if (!visitor->visitPathElOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitPathEl(t);

}

static void visitPathOrInspFactor(MetaModelVisitor *visitor, PathOrInspFactor *t)
{

   /*
   struct PathOrInspFactor : public Factor {
   public:
      list <PathEl *> PathEls;
      View *Inspection;
   */

   if (!visitor->visitPathOrInspFactorOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitFactor(t);
   visitor->visitPathOrInspFactor(t);

   for (auto v : t->PathEls) {
      visitPathEl(visitor,v);
   }

}

static void visitEnumAssignment(MetaModelVisitor *visitor, EnumAssignment *t)
{

   /*
   struct EnumAssignment : public MMObject {
   public:
      Expression *ValueToAssign;
      EnumNode *MinEnumValue;
      EnumNode *MaxEnumValue;
   */

   if (!visitor->visitEnumAssignmentOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitEnumAssignment(t);

}

static void visitEnumMapping(MetaModelVisitor *visitor, EnumMapping *t)
{

   /*
   struct EnumMapping : public Factor {
   public:
      PathOrInspFactor *EnumValue;
      list <EnumAssignment *> Cases;
   */

   if (!visitor->visitEnumMappingOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitFactor(t);
   visitor->visitEnumMapping(t);

   for (auto v : t->Cases) {
      visitEnumAssignment(visitor,v);
   }

}

static void visitClassRef(MetaModelVisitor *visitor, ClassRef *t)
{

   /*
   struct ClassRef : public MMObject {
   public:
      Class *Ref;
   */

   if (!visitor->visitClassRefOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitClassRef(t);

}

static void visitActualArgument(MetaModelVisitor *visitor, ActualArgument *t)
{

   /*
   struct ActualArgument : public MMObject {
   public:
      Argument *FormalArgument;
      enum {ExpressionVal, AllOf} Kind;
      list <Expression *> Expression;
      list <ClassRef *> ObjectClasses;
   */

   if (!visitor->visitActualArgumentOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitActualArgument(t);

   for (auto v : t->Expression) {
      visitExpression(visitor,v);
   }

   for (auto v : t->ObjectClasses) {
      visitClassRef(visitor,v);
   }

}

static void visitFunctionCall(MetaModelVisitor *visitor, FunctionCall *t)
{

   /*
   struct FunctionCall : public Factor {
   public:
      FunctionDef *Function;
      list <ActualArgument *> Arguments;
   */

   if (!visitor->visitFunctionCallOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitFactor(t);
   visitor->visitFunctionCall(t);

   for (auto v : t->Arguments) {
      visitActualArgument(visitor,v);
   }

}

static void visitRuntimeParamRef(MetaModelVisitor *visitor, RuntimeParamRef *t)
{

   /*
   struct RuntimeParamRef : public Factor {
   public:
      AttrOrParam *RuntimeParam;
   */

   if (!visitor->visitRuntimeParamRefOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitFactor(t);
   visitor->visitRuntimeParamRef(t);

}

static void visitConstant(MetaModelVisitor *visitor, Constant *t)
{

   /*
   struct Constant : public Factor {
   public:
      string Value;
      enum {Undefined, Numeric, Text, Enumeration} Kind;
   */

   if (!visitor->visitConstantOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitFactor(t);
   visitor->visitConstant(t);

}

static void visitClassConst(MetaModelVisitor *visitor, ClassConst *t)
{

   /*
   struct ClassConst : public Factor {
   public:
      Class *Class;
   */

   if (!visitor->visitClassConstOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitFactor(t);
   visitor->visitClassConst(t);

}

static void visitAttributeConst(MetaModelVisitor *visitor, AttributeConst *t)
{

   /*
   struct AttributeConst : public Factor {
   public:
      AttrOrParam *Attribute;
   */

   if (!visitor->visitAttributeConstOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitFactor(t);
   visitor->visitAttributeConst(t);

}

static void visitUnitRef(MetaModelVisitor *visitor, UnitRef *t)
{

   /*
   struct UnitRef : public Factor {
   public:
      Unit *Unit;
   */

   if (!visitor->visitUnitRefOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitFactor(t);
   visitor->visitUnitRef(t);

}

static void visitUnitFunction(MetaModelVisitor *visitor, UnitFunction *t)
{

   /*
   struct UnitFunction : public Factor {
   public:
      string Explanation;
   */

   if (!visitor->visitUnitFunctionOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitFactor(t);
   visitor->visitUnitFunction(t);

}

static void visitSimpleConstraint(MetaModelVisitor *visitor, SimpleConstraint *t)
{

   /*
   class SimpleConstraint : public Constraint { // 2.4 struct -> class
   public:
      enum {MandC, LowPercC, HighPercC} Kind;
      double Percentage;
      Expression *LogicalExpression;
   */

   if (!visitor->visitSimpleConstraintOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitConstraint(t);
   visitor->visitSimpleConstraint(t);

}

static void visitExistenceDef(MetaModelVisitor *visitor, ExistenceDef *t)
{

   /*
   class ExistenceDef : public PathOrInspFactor { // 2.4 struct -> class
   public:
      Class *Viewable;
   */

   if (!visitor->visitExistenceDefOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitPathOrInspFactor(t);
   visitor->visitExistenceDef(t);

}

static void visitExistenceConstraint(MetaModelVisitor *visitor, ExistenceConstraint *t)
{

   /*
   class ExistenceConstraint : public Constraint { // 2.4 struct -> class
   public:
      PathOrInspFactor *Attr;
      list<ExistenceDef *> ExistsIn;
   */

   if (!visitor->visitExistenceConstraintOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitConstraint(t);
   visitor->visitExistenceConstraint(t);

   for (auto v : t->ExistsIn) {
      visitExistenceDef(visitor,v);
   }

}

static void visitUniqueConstraint(MetaModelVisitor *visitor, UniqueConstraint *t)
{

   /*
   class UniqueConstraint : public Constraint { // 2.4 struct -> class
   public:
      list<Expression *> Where;
      enum {GlobalU, LocalU} Kind;
      list<PathOrInspFactor *> UniqueDef;
   */

   if (!visitor->visitUniqueConstraintOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitConstraint(t);
   visitor->visitUniqueConstraint(t);

   for (auto v : t->Where) {
      visitExpression(visitor,v);
   }

   for (auto v : t->UniqueDef) {
      visitPathOrInspFactor(visitor,v);
   }

}

static void visitSetConstraint(MetaModelVisitor *visitor, SetConstraint *t)
{

   /*
   class SetConstraint : public Constraint { // 2.4 struct -> class
   public:
      list<Expression *> Where;
      Expression *Constraint;
   */

   if (!visitor->visitSetConstraintOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitConstraint(t);
   visitor->visitSetConstraint(t);

   for (auto v : t->Where) {
      visitExpression(visitor,v);
   }

}

static void visitGraphic(MetaModelVisitor *visitor, Graphic *t)
{

   /*
   class Graphic : public ExtendableME {
      // MetaElement.Name := Name as defined in the INTERLIS-Model
   public:
      Expression *Where;
      // role from ASSOCIATION GraphicBase
      Class *Base;
      // role from ASSOCIATION GraphicRule
      list<DrawingRule *> DrawingRule;
   */

   if (!visitor->visitGraphicOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitExtendableME(t);
   visitor->visitGraphic(t);

   for (auto v : t->DrawingRule) {
      visitDrawingRule(visitor,v);
   }

}

static void visitSignParamAssignment(MetaModelVisitor *visitor, SignParamAssignment *t)
{

   /*
   struct SignParamAssignment : public MMObject {
   public:
      AttrOrParam *Param;
      Expression *Assignment;
   */

   if (!visitor->visitSignParamAssignmentOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitSignParamAssignment(t);

}

static void visitCondSignParamAssignment(MetaModelVisitor *visitor, CondSignParamAssignment *t)
{

   /*
   struct CondSignParamAssignment : public MMObject {
   public:
      Expression *Where;
      list<SignParamAssignment *> Assignments;
   */

   if (!visitor->visitCondSignParamAssignmentOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitCondSignParamAssignment(t);

   for (auto v : t->Assignments) {
      visitSignParamAssignment(visitor,v);
   }

}

static void visitDrawingRule(MetaModelVisitor *visitor, DrawingRule *t)
{

   /*
   class DrawingRule : public ExtendableME {
      // MetaElement.Name := Name as defined in the INTERLIS-Model
   public:
      list<CondSignParamAssignment *> Rule;
      // role from ASSOCIATION GraphicRule
      Graphic *Graphic;
      // role from ASSOCIATION SignClass
      Class *Class;
   */

   if (!visitor->visitDrawingRuleOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitExtendableME(t);
   visitor->visitDrawingRule(t);

   for (auto v : t->Rule) {
      visitCondSignParamAssignment(visitor,v);
   }

}

static void visitDocTextTranslation(MetaModelVisitor *visitor, DocTextTranslation *t)
{

   /*
   class DocTextTranslation : public MMObject {
   public:
      string Text;
   */

   if (!visitor->visitDocTextTranslationOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitDocTextTranslation(t);

}

static void visitMETranslation(MetaModelVisitor *visitor, METranslation *t)
{

   /*
   struct METranslation : public MMObject {
   public:
      MetaElement *Of;
      string TranslatedName;
      list <DocTextTranslation *> TranslatedDoc;
   */

   if (!visitor->visitMETranslationOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitMETranslation(t);

   for (auto v : t->TranslatedDoc) {
      visitDocTextTranslation(visitor,v);
   }

}

static void visitTranslation(MetaModelVisitor *visitor, Translation *t)
{

   /*
   class Translation : public MMObject {
   public:
      string Language;
      list <METranslation *> Translations;
   */

   if (!visitor->visitTranslationOverride()) {
      return;
   }

   display_debug(visitor,t);
   visitor->visitMMObject(t);
   visitor->visitTranslation(t);

   for (auto v : t->Translations) {
      visitMETranslation(visitor,v);
   }

}

